program_statement -> 
    program {{offset = 0}} id {{checkaddgreennode(id.lex)}} ( identifier_list ) ; program_statement_factored

program_statement_factored ->
    declarations program_statement_factored_fractored
    subprogram_declarations compound_statement .
    compound_statement .

program_statement_factored_fractored ->
    subprogram_declarations compound_statement .
    compound_statement .

identifier_list ->
    id {{checkaddbluenode(id.lex, TYPE_IDLIST)}} identifier_list_prime

identifier_list_prime ->
    , id {{checkaddbluenode(id.lex, TYPE_IDLIST)}} identifier_list_prime
    e

declarations ->
    declarations_prime

declarations_prime ->
    var id : type {{checkaddbluenode(id.lex, TYPE_PARAMLiST, offset); offset += type.width}}; declarations_prime
    e

type ->
    standard_type {{type.type = standard_type.type; type.width = standard_type.width}}
    array [ num{{1}} .. num{{2}} ] of standard_type {{type.width = (num2 - num1 + 1) * standard_type.width}} 
        [0:[type.type, <- , standard_type.type], 
        1: [TYPE_ARR_INT, if , TYPE_INT], 
        2: [TYPE_ARR_REAL, if , TYPE_REAL], 
        3: [TYPE_ERR, if , TYPE_ERR], 
        4: [TYPE_ERR*, otherwise, ]]


standard_type ->
    integer {{standard_type.type = TYPE_INT; standard_type.width = 4}}
    real {{standard_type.type = TYPE_REAL; standard_type.width = 8}}

subprogram_declarations ->
    subprogram_declarations_prime

subprogram_declarations_prime ->
    subprogram_declaration ; subprogram_declarations_prime
    e

subprogram_declaration ->
    subprogram_head subprogram_declaration_factored

subprogram_declaration_factored ->
    declarations ssubprogram_declaration_factored_factored
    subprogram_declarations compound_statement
    compound_statement

subprogram_declaration_factored_factored ->
    subprogram_declarations compound_statement
    compound_statement

subprogram_head ->
    procedure id {{checkaddgreennode(id.lex)}} subprogram_head_factored

subprogram_head_factored ->
    arguments {{eye_stack.peek().args = arguments.str}};
    {{eye_stack.peek().args = "" }}; 

arguments ->
    ( parameter_list {{arguments.str = parameter_list.str}})

parameter_list ->
    id : type {{checkaddbluenode(id.lex, type.type)}} parameter_list_prime {{parameter_list.str = type2str(type.type).parameter_list_prime.str}}

parameter_list_prime ->
    ; id : type {{checkaddbluenode(id.lex, type.type)}} parameter_list_prime {{parameter_list_prime.str = type2str(type.type).parameter_list_prime.str}}
    e {{parameter_list_prime.str = ""}}

compound_statement ->
    begin compound_statement_factored

compound_statement_factored ->
    optional_statements end
	end

optional_statements ->
    statement_list

statement_list ->
    statement statement_list_prime 

statement_list_prime ->
    ; statement statement_list_prime
    e

statement ->
    variable assignop expression
    [0:[statment.type, <- , variable.type, expression.type],
    1: [TYPE_ERR, if, TYPE_ERR, any]
    2: [TYPE_ERR, if, any, TYPE_ERR]    
    3: [TYPE_ERR*, if , TYPE_, !TYPE],
    1: [void, if , TYPE, TYPE],
    4: [TYPE_ERR*, otherwise]]
    procedure_statement
    begin statement_factored_one
    if expression {{assert(expression.type == TYPE_BOOL)}} then statement statement_factored_two
    while expression {{assert(expression.type == TYPE_BOOL)}} do statement

statement_factored_one ->
  optional_statements end
  end

statement_factored_two ->
  else statement
  e

variable ->
    id {{variable.i = getttype(id.lex)}} variable_factored {{variable.type = variable_factored.type}}

variable_factored ->
    e {{variable_factored.type = variable_factored.i}}
    [ expression ]
	[0:[variable_factored, <- , variable.i, expresion],
	1:[TYPE_ERR, if , TYPE_ERR , any],
	2:[TYPE_ERR, if , any , TYPE_ERR],
	3:[TYPE_ERR*, if , any , !TYPE_INT],
	4:[TYPE_INT, if , TYPE_ARR_INT, TYPE_INT],
	5:[TYPE_REAL, if, TYPE_ARR_REAL, TYPE_INT]]

procedure_statement ->
    call id procedure_statement_factored

procedure_statement_factored ->
    e
    ( expression_list )

 expression_list ->
    expression expression_list_prime

expression_list_prime ->
    , expression expression_list_prime
    e

expression ->
    simple_expression expression_factored

expression_factored ->
    e
    relop simple_expression

simple_expression ->
    term simple_expression_prime
    sign term simple_expression_prime

simple_expression_prime ->
    addop term simple_expression_prime
    e

term ->
    factor term_prime

term_prime ->
    mulop factor term_prime
    e

factor ->
    id factor_prime
    num
    ( expression )
    not factor

factor_prime ->	
	[ expression ]
	e 

sign ->
    +
    -

